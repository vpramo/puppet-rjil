# This is an autogenerated function, ported from the original legacy version.
# It /should work/ as is, but will not have all the benefits of the modern
# function API. You should see the function docs to learn how to add function
# signatures for type safety and to document this function using puppet-strings.
#
# https://puppet.com/docs/puppet/latest/custom_functions_ruby.html
#
# ---- original file header ----
##
## first_interface_with_ip
##
require 'ipaddr'

# ---- original file header ----
#
# @summary
#   
#This function does below stuffs.
#
#* Iterate through the 'interfaces' fact and return the first interface details
# which have any ip address set.
#* It can also accepts a comma separated interface names
#* The details it can provide is interface name, ip address, network, subnetmask.
#
#It takes two optional arguments
#
#1. what to return. Valid arguments are
#    interface: return interface name
#    ipaddress: return ipaddress
#    macaddress: return macaddress
#    network:  return network
#    netmask:  return netmask
#   By default it return interface name.
#
#2. Interface list - a comma separated interface list to check.
#    If not provided, it use 'interfaces' fact.
#
#  e.g
#    Below example return ipaddress of first interface from the list provided which
#  has any ip address set.
#
#  first_interface_with_ip('ipaddress','eth0,eth1,vhost0')
#
#
#
Puppet::Functions.create_function(:'first_interface_with_ip') do
  # @param args
  #   The original array of arguments. Port this to individually managed params
  #   to get the full benefit of the modern function API.
  #
  # @return [Data type]
  #   Describe what the function returns here
  #
  dispatch :default_impl do
    # Call the method named 'default_impl' when this is matched
    # Port this to match individual params for better type safety
    repeated_param 'Any', :args
  end


  def default_impl(*args)
    

    kind_arg       = args.shift
    interface_list = args.shift
    ifs = defined?(interface_list) ? interface_list : lookupvar('interfaces')
    raise(ArgumentError, "interfaces cannot be empty") if !ifs || ifs.empty?


    kind = defined?(kind_arg) ? kind_arg : 'interface'

    ifs.split(',').each do |iface|
      if lookupvar("ipaddress_#{iface}")
        if kind == 'interface'
          return iface
        else
          return lookupvar("#{kind}_#{iface}")
        end
      end
    end
  
  end
end
